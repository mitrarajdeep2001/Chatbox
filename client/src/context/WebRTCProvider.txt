import React, {
  createContext,
  useContext,
  useRef,
  useState,
  ReactNode,
  MutableRefObject,
  useEffect,
  useCallback,
} from "react";
import { useSocket } from "./SocketProvider";
import webrtc from "@/lib/webrtc";

type WebRTCContextType = {
  handleCall: ({
    video,
    audio,
    to,
  }: {
    video: boolean;
    audio: boolean;
    to: string;
  }) => Promise<void>;
  myStream: MediaStream | null;
  remoteStream: MediaStream | null;
  handleEndCall: () => void;
};

const WebRTC = createContext<WebRTCContextType | undefined>(undefined);

export const useWebRTC = (): WebRTCContextType => {
  const context = useContext(WebRTC);
  if (!context) {
    throw new Error("useWebRTC must be used within a WebRTCProvider");
  }
  return context;
};

type WebRTCProviderProps = {
  children: ReactNode;
};

const WebRTCProvider: React.FC<WebRTCProviderProps> = ({ children }) => {
  const { emitEvent, listenToEvent } = useSocket();
  const [myStream, setMyStream] = useState<MediaStream | null>(null);
  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
  const [remoteSocketID, setRemoteSocketID] = useState<string | null>(null);

  const handleCall = useCallback(
    async ({
      video,
      audio,
      to,
    }: {
      video: boolean;
      audio: boolean;
      to: string;
    }) => {
      const stream = await navigator.mediaDevices.getUserMedia({
        video,
        audio,
      });
      setMyStream(stream);
      const offer = await webrtc.createOffer();
      console.log(offer, "offer");

      emitEvent("event:callUser", {
        offer,
        roomId: to,
        video,
        audio,
      });
    },
    []
  );

  const handleEndCall = useCallback(() => {
    if (myStream) {
      myStream.getTracks().forEach((track) => track.stop()); // Stop all tracks
    }
    setMyStream(null);
    setRemoteStream(null);
  }, [myStream]);

  const handleIncomingCall = useCallback(
    async ({
      offer,
      video,
      audio,
      from,
    }: {
      offer: RTCSessionDescriptionInit;
      video: boolean;
      audio: boolean;
      from: string;
    }) => {
      const stream = await navigator.mediaDevices.getUserMedia({
        video,
        audio,
      });
      setMyStream(stream);
      console.log(offer, "offer****");
      
      const answer = await webrtc.createAnswer(offer);
      emitEvent("event:answerCall", {
        answer,
        roomId: from,
      });

      setRemoteSocketID(from);
    },
    []
  );

  // send local stream to remote peer
  const sendStreams = useCallback(() => {
    if (myStream) {
      for (const track of myStream.getTracks()) {
        webrtc.webrtc.addTrack(track, myStream);
      }
    }
  }, [myStream]);

  const handleCallAccepted = useCallback(
    async ({ answer }: { answer: RTCSessionDescriptionInit }) => {
      // await webrtc.setRemoteDescription(answer);
      console.log("Call accepted");
      sendStreams();
    },
    [sendStreams]
  );

  const handleIceCandidate = useCallback(async ({ candidate }: { candidate: RTCIceCandidate }) => {
    await webrtc.webrtc.addIceCandidate(new RTCIceCandidate(candidate));
    console.log("Ice candidate added");
  }, []);

  useEffect(() => {
    // listen to remote stream
    webrtc.webrtc.addEventListener("track", (event: RTCTrackEvent) => {
      console.log("Got remote stream");
      setRemoteStream(event.streams[0]);
    });

    webrtc.webrtc.addEventListener("icecandidate", (event: RTCPeerConnectionIceEvent) => {
      if (event.candidate) {
        console.log("Ice candidate found", event.candidate);
        
        emitEvent("event:iceCandidate", {
          candidate: event.candidate,
          roomId: remoteSocketID,
        });
      }
    });
  }, []);

  // const handleNegotiationNeeded = useCallback(async () => {
  //   console.log("Negotiation needed");
    
  //   const offer = await webrtc.createOffer();
  //   emitEvent("event:negotiationNeeded", { offer, roomId: remoteSocketID });
  // }, [remoteSocketID, emitEvent]);

  // const handleNegotiate = useCallback(
  //   async ({
  //     offer,
  //     from,
  //   }: {
  //     offer: RTCSessionDescriptionInit;
  //     from: string;
  //   }) => {
  //     const answer = await webrtc.createAnswer(offer);
  //     emitEvent("event:callAccepted", {
  //       answer,
  //       roomId: from,
  //     });
  //   },
  //   [remoteSocketID, emitEvent]
  // );
  // const handleNegotiationCompleted = useCallback(
  //   async ({ answer }: { answer: RTCSessionDescriptionInit }) => {
  //     await webrtc.setRemoteDescription(answer);
  //     console.log("Negotiation completed");
  //   },
  //   []
  // );

  // useEffect(() => {
  //   webrtc.webrtc.addEventListener(
  //     "negotiationneeded",
  //     handleNegotiationNeeded
  //   );
  //   return () => {
  //     webrtc.webrtc.removeEventListener(
  //       "negotiationneeded",
  //       handleNegotiationNeeded
  //     );
  //   };
  // }, [handleNegotiationNeeded]);

  useEffect(() => {
    listenToEvent("event:incomingCall", handleIncomingCall);
    listenToEvent("event:callAccepted", handleCallAccepted);
    listenToEvent("event:iceCandidate", handleIceCandidate);
    // listenToEvent("event:negotiate", handleNegotiate);
    // listenToEvent("event:negotiationCompleted", handleNegotiationCompleted);
  }, [
    handleIncomingCall,
    handleCallAccepted,
    // handleNegotiate,
    // handleNegotiationCompleted,
  ]);

  return (
    <WebRTC.Provider
      value={{ handleCall, myStream, remoteStream, handleEndCall }}
    >
      {children}
    </WebRTC.Provider>
  );
};

export default WebRTCProvider;
